/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	
	var Table = __webpack_require__( 1 );

	Table.init();

	module.exports = Table;


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	var Organism = __webpack_require__(2);

	var Table = Organism.extend( {
	  selector: '.o-table',

	  ui: {
	    sortables: '.sortable'
	  },

	  events: {
	  	'click .sortable': 'sortColumn'
	  },

	  getTableData: function() {
	  	if ( this.tableData.length ) {
	     	return;
	    }

	  	for ( var i = 1, row; row = this.element.rows[ i ]; i++ ) {
	      this.tableData[i] = [];
	      for ( var j = 0, cell; cell = row.cells[ j ]; j++ ) {
	        this.tableData[i][j] = row.cells[ j ].textContent;
	        this.tableData[i][j].row = i;
	      }
	    }
	    console.log( this.tableData );
	    return this.tableData
	  },

	  initialize: function( ) {
	    this.isTableSorted = false;
	    this.sortColumn = 0;
	    this.tableData = [];
	    this.getTableData();
	  },

	  sortColumn: function( ) {
	    console.log();
	  },

	  arraySorter: function( order, sortType ) {
	  	return function( a, b ) {
		  // Set a and b to the first Array in each Array-of-Arrays
		  a = a[0];
		  b = b[0];

		  // For number sort, convert a & b to numbers.
		  if ( sortType === 'number' ) {
		    a = Number( a.replace( /[^\d.-]/g, '' ) );
		    b = Number( b.replace( /[^\d.-]/g, '' ) );
		  }

		  return b - a;
	  	};
	  }
	} );

	module.exports = Table;


/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	/* ==========================================================================
	   Organism

	   Organism Atomic Component

	   ========================================================================== */

	'use strict';

	var AtomicComponent = __webpack_require__( 3 );
	var TYPES = __webpack_require__( 11 ).TYPES;
	var Organism = AtomicComponent.extend( {
	  TYPE: TYPES.ORGANISM,
	  CHILD_TYPES: [TYPES.MOLECULE, TYPES.ATOM]
	} );

	module.exports = Organism;


/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	/* ==========================================================================
	   AtomicComponent

	   Base Atomic Component

	   Contains code copied from the following with major modifications :

	   - Backbone.js ( http://backbonejs.org/docs/backbone.html ).
	   ========================================================================== */
	'use strict';

	var _assign = __webpack_require__(4).assign;
	var _isFunction = __webpack_require__(6).isFunction;
	var dataSet = __webpack_require__(7).dataSet;
	var Delegate = __webpack_require__(8).Delegate;
	var Events = __webpack_require__(10);

	function AtomicComponent(element, attrs) {
	  this.u_id = this._uniqueId('ac');
	  this.ui = {};
	  this.element = element;
	  attrs = attrs || (attrs = {});
	  _assign(this, attrs, this.defaults);
	  this.ensureElement();
	  this.setCachedElements();
	  this.initialize.apply(this, arguments);
	}

	// Public Methods and properties.
	_assign(AtomicComponent.prototype, Events, {

	  tagName: 'div',

	  initialize: function initialize() {},

	  render: function() {
	    return this;
	  },

	  ensureElement: function() {
	    if (!this.element) {
	      var attrs = _assign({}, this.attributes);
	      if (this.id) attrs.id = this.id || this.u_id;
	      if (this.className) attrs['class'] = this.className;
	      this.setElement(document.createElement(this.tagName));
	      this.setElementAttributes(attrs);
	    } else {
	      this.setElement(this.element);
	    }
	  },

	  setElement: function(element) {
	    this.undelegateEvents();
	    this.element = element;
	    this.delegateEvents();

	    return this;
	  },

	  setCachedElements: function() {
	    var key;

	    for (key in this.ui) {
	      if (this.ui.hasOwnProperty(key)) {
	        this[key] = this.element.querySelector(this.ui[key]);
	      }
	    }

	    return this;
	  },

	  remove: function() {
	    if (this.element) {
	      this.element.parentNode.removeChild(this.element);
	      if (this.element.view) delete this.element.view;
	      delete this.element;
	    }

	    this.undelegateEvents();

	    return true;
	  },

	  setElementAttributes: function(attributes) {
	    var property;
	    for (property in attributes) {
	      if (attributes.hasOwnProperty(property)) {
	        this.element.setAttribute(property, attributes[property]);
	      }
	    }
	  },

	  addClass: function(className, element) {
	    (element || this.element).classList.add(className);
	    return this;
	  },

	  removeClass: function(className, element) {
	    (element || this.element).classList.remove(className);

	    return this;
	  },

	  delegateEvents: function(events) {
	    var key;
	    var method;
	    var match;
	    var delegateEventSplitter = /^(\S+)\s*(.*)$/;

	    events = events || (events = this.events);
	    if (!events) return this;
	    this.undelegateEvents();
	    this._delegate = new Delegate(this.element);
	    for (key in events) {
	      method = events[key];
	      if (_isFunction(this[method])) method = this[method];
	      if (!method) continue;
	      match = key.match(delegateEventSplitter);
	      this.delegate(match[1], match[2], method.bind(this));
	    }

	    return this;
	  },

	  delegate: function(eventName, selector, listener) {
	    this._delegate.on(eventName, selector, listener);
	    return this;
	  },

	  undelegateEvents: function() {
	    if (this._delegate) {
	      this._delegate.destroy();
	    }

	    return this;
	  },

	  _uniqueId: function(prefix) {
	    return prefix + '_' + Math.random().toString(36).substr(2, 9);
	  }

	});


	// Static Methods
	AtomicComponent.extend = function extend(attributes) {
	  function child() {
	    this._super = AtomicComponent.prototype;
	    return AtomicComponent.apply(this, arguments);
	  }
	  child.prototype = Object.create(AtomicComponent.prototype);
	  _assign(child.prototype, attributes);
	  _assign(child, AtomicComponent);
	  if (attributes && attributes.hasOwnProperty('selector')) {
	    child.selector = attributes.selector;
	  }

	  return child;
	};


	AtomicComponent.init = function init() {
	  var elements = document.querySelectorAll(this.selector);
	  var element;
	  var view;

	  for (var i = 0; i < elements.length; ++i) {
	    element = elements[i];
	    view = new this(element);
	  }

	  return this;
	};

	module.exports = AtomicComponent;


/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	/* ==========================================================================
	   Assign

	   Code copied from the following with moderate modifications :

	   - https://github.com/maslennikov/shallow-extend
	     Copyright (c) 2014 Alexey Maslennikov
	   ========================================================================== */

	'use strict';

	var fnBind = __webpack_require__( 5 ).fnBind;

	/**
	* @param {object} object - JavaScript object.
	* @returns {boolean} True if object is plain Javascript object.
	*/
	function _isPlainObject( object ) {
	  return Object.prototype.toString.call( object ) === '[object Object]';
	}

	/**
	* Copies properties of all sources to the destination object overriding its own
	* existing properties. When assigning from multiple sources, fields of every
	* next source will override same named fields of previous sources.
	*
	* @param {Object} destination object.
	* @returns {Object} assigned destination object.
	*/
	function assign( destination ) {
	  destination = destination || {};
	  var hasOwnProp;
	  for ( var i = 1; i < arguments.length; i++ ) {
	    var source = arguments[i] || {};
	    hasOwnProp = fnBind( Object.hasOwnProperty, source );
	    for ( var key in source ) {
	      if ( hasOwnProp( key ) ) {
	        var value = source[key];
	        if ( _isPlainObject( value ) ) {
	          assign( destination[key] = {}, value );
	        } else {
	          destination[key] = source[key];
	        }
	      }
	    }
	  }
	  return destination;
	}

	// Expose public methods.
	module.exports = { assign: assign };


/***/ },
/* 5 */
/***/ function(module, exports) {

	
	/* ==========================================================================
	   fnBind

	   Code copied from the following with minimal modifications :

	   - https://raw.githubusercontent.com/Modernizr/Modernizr/
	     74655c45ad2cd05c002e4802cdd74cba70310f08/src/fnBind.js

	   Polyfill for BlackBerry 7. IE8- gets a simplified no-js page.
	   To test whether the polyfill is needed by a particular browser,
	   the following code can temporarily be placed in the document <head>:

	   alert( typeof Function.prototype.bind == 'function' );
	   ========================================================================== */

	'use strict';


	/**
	 * Function.prototype.bind polyfill.
	 *
	 * @access private
	 * @function fnBind
	 * @param {Function} fn - A function you want to change `this` reference to.
	 * @param {Object} context - The `this` you want to call the function with.
	 * @returns {Function} The wrapped version of the supplied function.
	 */
	function fnBind(fn, context) {
	    return function() {
	        return fn.apply(context, arguments);
	    };
	}


	// Expose public methods.
	module.exports = {
	    fnBind: fnBind
	};

/***/ },
/* 6 */
/***/ function(module, exports) {

	/* ==========================================================================
	   Javascript Type Checkers

	   Various utility functions to check Javascript types and primitives.
	   Copied from:
	   https://github.com/angular/angular.js/blob/master/src/Angular.js.

	   Copyright (c) 2010-2015 Google, Inc. http://angularjs.org
	   ========================================================================== */

	'use strict';

	var _toString = Object.prototype.toString;

	/**
	 * @name isUndefined
	 * @kind function
	 *
	 * @description
	 * Determines if a reference is undefined.
	 *
	 * @param {*} value Reference to check.
	 * @returns {boolean} True if `value` is undefined.
	 */
	function isUndefined( value ) {
	  return typeof value === 'undefined';
	}


	/**
	 * @name isDefined
	 * @kind function
	 *
	 * @description
	 * Determines if a reference is defined.
	 *
	 * @param {*} value Reference to check.
	 * @returns {boolean} True if `value` is defined.
	 */
	function isDefined( value ) {
	  return typeof value !== 'undefined';
	}


	/**
	 * @name isObject
	 * @kind function
	 *
	 * @description
	 * Determines if a reference is an `Object`.
	 * Unlike `typeof` in JavaScript, `null`s are not
	 * considered to be objects. Note that JavaScript arrays are objects.
	 *
	 * @param {*} value Reference to check.
	 * @returns {boolean} True if `value` is an `Object` but not `null`.
	 */
	function isObject( value ) {
	  // http://jsperf.com/isobject4
	  return value !== null && typeof value === 'object';
	}


	/**
	 * @name isString
	 * @kind function
	 *
	 * @description
	 * Determines if a reference is a `String`.
	 *
	 * @param {*} value Reference to check.
	 * @returns {boolean} True if `value` is a `String`.
	 */
	function isString( value ) {
	  return _toString.call( value ) === '[object String]';
	}


	/**
	 * @name isNumber
	 * @kind function
	 *
	 * @description
	 * Determines if a reference is a `Number`.
	 *
	 * This includes the "special" numbers `NaN`, `+Infinity` and `-Infinity`.
	 *
	 * If you wish to exclude these then you can use the native
	 * [`isFinite'](https://developer.mozilla.org/en-US/docs/Web/JavaScript/
	 *                      Reference/Global_Objects/isFinite)
	 * method.
	 *
	 * @param {*} value Reference to check.
	 * @returns {boolean} True if `value` is a `Number`.
	 */
	function isNumber( value ) {
	  return _toString.call( value ) === '[object Number]';
	}


	/**
	 * @name isDate
	 * @kind function
	 *
	 * @description
	 * Determines if a value is a date.
	 *
	 * @param {*} value Reference to check.
	 * @returns {boolean} True if `value` is a `Date`.
	 */
	function isDate( value ) {
	  return _toString.call( value ) === '[object Date]';
	}


	/**
	 * @name isArray
	 * @kind function
	 *
	 * @description
	 * Determines if a reference is an `Array`.
	 *
	 * @param {*} value Reference to check.
	 * @returns {boolean} True if `value` is an `Array`.
	 */
	var isArray = Array.isArray || function isArray( value ) {
	  return _toString.call( value ) === '[object Array]';
	};


	/**
	 * @name isFunction
	 * @kind function
	 *
	 * @description
	 * Determines if a reference is a `Function`.
	 *
	 * @param {*} value Reference to check.
	 * @returns {boolean} True if `value` is a `Function`.
	 */
	function isFunction( value ) {
	  return _toString.call( value ) === '[object Function]';
	}

	/**
	 * @name isEmpty
	 * @kind function
	 *
	 * @description
	 * Determines if a reference is empty.
	 *
	 * @param {*} value Reference to check.
	 * @returns {boolean} True if `value` is empty.
	 */
	function isEmpty( value ) {
	  return isUndefined( value ) ||
	         value === null ||
	         isString( value ) &&
	         value.length <= 0 ||
	         ( /^\s*$/ ).test( value );
	}


	// Expose public methods.
	module.exports = {
	  isUndefined: isUndefined,
	  isDefined:   isDefined,
	  isObject:    isObject,
	  isString:    isString,
	  isNumber:    isNumber,
	  isDate:      isDate,
	  isArray:     isArray,
	  isFunction:  isFunction,
	  isEmpty:     isEmpty
	};


/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	
	'use strict';

	var _assign = __webpack_require__(4).assign;

	/**
	 * Converts a string from selector-case to camelCase.
	 * @param {string} str - The string in selector-case form.
	 * @returns {string} The string in camelCase form.
	 */
	function _toCamelCase(str) {
	    return str.replace(/\-([a-z])/g, function(all, match) {
	        return match.toUpperCase();
	    });
	}

	/**
	 * Get dataset from DOM element.
	 * Contains code copied from
	 * https://github.com/remy/polyfills/blob/master/dataset.js.
	 * @param {HTMLElement} element - The element to check for dataset support.
	 * @returns {Object} The data set.
	 */
	function dataSet(element) {
	    if (document.documentElement.dataset) {
	        return _assign({}, element.dataset);
	    }

	    var dataset = {};
	    var regex = /^data-(.+)/;
	    var attr;
	    var match;
	    for (var i = 0; i < element.attributes.length; i++) {
	        attr = element.attributes[i];
	        match = attr.name.match(regex);
	        if (match) {
	            dataset[_toCamelCase(match[1])] = attr.value;
	        }
	    }

	    return dataset;
	}

	// Expose public methods.
	module.exports = {
	    dataSet: dataSet
	};

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	/*jshint browser:true, node:true*/

	'use strict';

	/**
	 * @preserve Create and manage a DOM event delegator.
	 *
	 * @version 0.3.0
	 * @codingstandard ftlabs-jsv2
	 * @copyright The Financial Times Limited [All Rights Reserved]
	 * @license MIT License (see LICENSE.txt)
	 */
	var Delegate = __webpack_require__(9);

	module.exports = function(root) {
	  return new Delegate(root);
	};

	module.exports.Delegate = Delegate;


/***/ },
/* 9 */
/***/ function(module, exports) {

	/*jshint browser:true, node:true*/

	'use strict';

	module.exports = Delegate;

	/**
	 * DOM event delegator
	 *
	 * The delegator will listen
	 * for events that bubble up
	 * to the root node.
	 *
	 * @constructor
	 * @param {Node|string} [root] The root node or a selector string matching the root node
	 */
	function Delegate(root) {

	  /**
	   * Maintain a map of listener
	   * lists, keyed by event name.
	   *
	   * @type Object
	   */
	  this.listenerMap = [{}, {}];
	  if (root) {
	    this.root(root);
	  }

	  /** @type function() */
	  this.handle = Delegate.prototype.handle.bind(this);
	}

	/**
	 * Start listening for events
	 * on the provided DOM element
	 *
	 * @param  {Node|string} [root] The root node or a selector string matching the root node
	 * @returns {Delegate} This method is chainable
	 */
	Delegate.prototype.root = function(root) {
	  var listenerMap = this.listenerMap;
	  var eventType;

	  // Remove master event listeners
	  if (this.rootElement) {
	    for (eventType in listenerMap[1]) {
	      if (listenerMap[1].hasOwnProperty(eventType)) {
	        this.rootElement.removeEventListener(eventType, this.handle, true);
	      }
	    }
	    for (eventType in listenerMap[0]) {
	      if (listenerMap[0].hasOwnProperty(eventType)) {
	        this.rootElement.removeEventListener(eventType, this.handle, false);
	      }
	    }
	  }

	  // If no root or root is not
	  // a dom node, then remove internal
	  // root reference and exit here
	  if (!root || !root.addEventListener) {
	    if (this.rootElement) {
	      delete this.rootElement;
	    }
	    return this;
	  }

	  /**
	   * The root node at which
	   * listeners are attached.
	   *
	   * @type Node
	   */
	  this.rootElement = root;

	  // Set up master event listeners
	  for (eventType in listenerMap[1]) {
	    if (listenerMap[1].hasOwnProperty(eventType)) {
	      this.rootElement.addEventListener(eventType, this.handle, true);
	    }
	  }
	  for (eventType in listenerMap[0]) {
	    if (listenerMap[0].hasOwnProperty(eventType)) {
	      this.rootElement.addEventListener(eventType, this.handle, false);
	    }
	  }

	  return this;
	};

	/**
	 * @param {string} eventType
	 * @returns boolean
	 */
	Delegate.prototype.captureForType = function(eventType) {
	  return ['blur', 'error', 'focus', 'load', 'resize', 'scroll'].indexOf(eventType) !== -1;
	};

	/**
	 * Attach a handler to one
	 * event for all elements
	 * that match the selector,
	 * now or in the future
	 *
	 * The handler function receives
	 * three arguments: the DOM event
	 * object, the node that matched
	 * the selector while the event
	 * was bubbling and a reference
	 * to itself. Within the handler,
	 * 'this' is equal to the second
	 * argument.
	 *
	 * The node that actually received
	 * the event can be accessed via
	 * 'event.target'.
	 *
	 * @param {string} eventType Listen for these events
	 * @param {string|undefined} selector Only handle events on elements matching this selector, if undefined match root element
	 * @param {function()} handler Handler function - event data passed here will be in event.data
	 * @param {Object} [eventData] Data to pass in event.data
	 * @returns {Delegate} This method is chainable
	 */
	Delegate.prototype.on = function(eventType, selector, handler, useCapture) {
	  var root, listenerMap, matcher, matcherParam;

	  if (!eventType) {
	    throw new TypeError('Invalid event type: ' + eventType);
	  }

	  // handler can be passed as
	  // the second or third argument
	  if (typeof selector === 'function') {
	    useCapture = handler;
	    handler = selector;
	    selector = null;
	  }

	  // Fallback to sensible defaults
	  // if useCapture not set
	  if (useCapture === undefined) {
	    useCapture = this.captureForType(eventType);
	  }

	  if (typeof handler !== 'function') {
	    throw new TypeError('Handler must be a type of Function');
	  }

	  root = this.rootElement;
	  listenerMap = this.listenerMap[useCapture ? 1 : 0];

	  // Add master handler for type if not created yet
	  if (!listenerMap[eventType]) {
	    if (root) {
	      root.addEventListener(eventType, this.handle, useCapture);
	    }
	    listenerMap[eventType] = [];
	  }

	  if (!selector) {
	    matcherParam = null;

	    // COMPLEX - matchesRoot needs to have access to
	    // this.rootElement, so bind the function to this.
	    matcher = matchesRoot.bind(this);

	  // Compile a matcher for the given selector
	  } else if (/^[a-z]+$/i.test(selector)) {
	    matcherParam = selector;
	    matcher = matchesTag;
	  } else if (/^#[a-z0-9\-_]+$/i.test(selector)) {
	    matcherParam = selector.slice(1);
	    matcher = matchesId;
	  } else {
	    matcherParam = selector;
	    matcher = matches;
	  }

	  // Add to the list of listeners
	  listenerMap[eventType].push({
	    selector: selector,
	    handler: handler,
	    matcher: matcher,
	    matcherParam: matcherParam
	  });

	  return this;
	};

	/**
	 * Remove an event handler
	 * for elements that match
	 * the selector, forever
	 *
	 * @param {string} [eventType] Remove handlers for events matching this type, considering the other parameters
	 * @param {string} [selector] If this parameter is omitted, only handlers which match the other two will be removed
	 * @param {function()} [handler] If this parameter is omitted, only handlers which match the previous two will be removed
	 * @returns {Delegate} This method is chainable
	 */
	Delegate.prototype.off = function(eventType, selector, handler, useCapture) {
	  var i, listener, listenerMap, listenerList, singleEventType;

	  // Handler can be passed as
	  // the second or third argument
	  if (typeof selector === 'function') {
	    useCapture = handler;
	    handler = selector;
	    selector = null;
	  }

	  // If useCapture not set, remove
	  // all event listeners
	  if (useCapture === undefined) {
	    this.off(eventType, selector, handler, true);
	    this.off(eventType, selector, handler, false);
	    return this;
	  }

	  listenerMap = this.listenerMap[useCapture ? 1 : 0];
	  if (!eventType) {
	    for (singleEventType in listenerMap) {
	      if (listenerMap.hasOwnProperty(singleEventType)) {
	        this.off(singleEventType, selector, handler);
	      }
	    }

	    return this;
	  }

	  listenerList = listenerMap[eventType];
	  if (!listenerList || !listenerList.length) {
	    return this;
	  }

	  // Remove only parameter matches
	  // if specified
	  for (i = listenerList.length - 1; i >= 0; i--) {
	    listener = listenerList[i];

	    if ((!selector || selector === listener.selector) && (!handler || handler === listener.handler)) {
	      listenerList.splice(i, 1);
	    }
	  }

	  // All listeners removed
	  if (!listenerList.length) {
	    delete listenerMap[eventType];

	    // Remove the main handler
	    if (this.rootElement) {
	      this.rootElement.removeEventListener(eventType, this.handle, useCapture);
	    }
	  }

	  return this;
	};


	/**
	 * Handle an arbitrary event.
	 *
	 * @param {Event} event
	 */
	Delegate.prototype.handle = function(event) {
	  var i, l, type = event.type, root, phase, listener, returned, listenerList = [], target, /** @const */ EVENTIGNORE = 'ftLabsDelegateIgnore';

	  if (event[EVENTIGNORE] === true) {
	    return;
	  }

	  target = event.target;

	  // Hardcode value of Node.TEXT_NODE
	  // as not defined in IE8
	  if (target.nodeType === 3) {
	    target = target.parentNode;
	  }

	  root = this.rootElement;

	  phase = event.eventPhase || ( event.target !== event.currentTarget ? 3 : 2 );
	  
	  switch (phase) {
	    case 1: //Event.CAPTURING_PHASE:
	      listenerList = this.listenerMap[1][type];
	    break;
	    case 2: //Event.AT_TARGET:
	      if (this.listenerMap[0] && this.listenerMap[0][type]) listenerList = listenerList.concat(this.listenerMap[0][type]);
	      if (this.listenerMap[1] && this.listenerMap[1][type]) listenerList = listenerList.concat(this.listenerMap[1][type]);
	    break;
	    case 3: //Event.BUBBLING_PHASE:
	      listenerList = this.listenerMap[0][type];
	    break;
	  }

	  // Need to continuously check
	  // that the specific list is
	  // still populated in case one
	  // of the callbacks actually
	  // causes the list to be destroyed.
	  l = listenerList.length;
	  while (target && l) {
	    for (i = 0; i < l; i++) {
	      listener = listenerList[i];

	      // Bail from this loop if
	      // the length changed and
	      // no more listeners are
	      // defined between i and l.
	      if (!listener) {
	        break;
	      }

	      // Check for match and fire
	      // the event if there's one
	      //
	      // TODO:MCG:20120117: Need a way
	      // to check if event#stopImmediatePropagation
	      // was called. If so, break both loops.
	      if (listener.matcher.call(target, listener.matcherParam, target)) {
	        returned = this.fire(event, target, listener);
	      }

	      // Stop propagation to subsequent
	      // callbacks if the callback returned
	      // false
	      if (returned === false) {
	        event[EVENTIGNORE] = true;
	        event.preventDefault();
	        return;
	      }
	    }

	    // TODO:MCG:20120117: Need a way to
	    // check if event#stopPropagation
	    // was called. If so, break looping
	    // through the DOM. Stop if the
	    // delegation root has been reached
	    if (target === root) {
	      break;
	    }

	    l = listenerList.length;
	    target = target.parentElement;
	  }
	};

	/**
	 * Fire a listener on a target.
	 *
	 * @param {Event} event
	 * @param {Node} target
	 * @param {Object} listener
	 * @returns {boolean}
	 */
	Delegate.prototype.fire = function(event, target, listener) {
	  return listener.handler.call(target, event, target);
	};

	/**
	 * Check whether an element
	 * matches a generic selector.
	 *
	 * @type function()
	 * @param {string} selector A CSS selector
	 */
	var matches = (function(el) {
	  if (!el) return;
	  var p = el.prototype;
	  return (p.matches || p.matchesSelector || p.webkitMatchesSelector || p.mozMatchesSelector || p.msMatchesSelector || p.oMatchesSelector);
	}(Element));

	/**
	 * Check whether an element
	 * matches a tag selector.
	 *
	 * Tags are NOT case-sensitive,
	 * except in XML (and XML-based
	 * languages such as XHTML).
	 *
	 * @param {string} tagName The tag name to test against
	 * @param {Element} element The element to test with
	 * @returns boolean
	 */
	function matchesTag(tagName, element) {
	  return tagName.toLowerCase() === element.tagName.toLowerCase();
	}

	/**
	 * Check whether an element
	 * matches the root.
	 *
	 * @param {?String} selector In this case this is always passed through as null and not used
	 * @param {Element} element The element to test with
	 * @returns boolean
	 */
	function matchesRoot(selector, element) {
	  /*jshint validthis:true*/
	  if (this.rootElement === window) return element === document;
	  return this.rootElement === element;
	}

	/**
	 * Check whether the ID of
	 * the element in 'this'
	 * matches the given ID.
	 *
	 * IDs are case-sensitive.
	 *
	 * @param {string} id The ID to test against
	 * @param {Element} element The element to test with
	 * @returns boolean
	 */
	function matchesId(id, element) {
	  return id === element.id;
	}

	/**
	 * Short hand for off()
	 * and root(), ie both
	 * with no parameters
	 *
	 * @return void
	 */
	Delegate.prototype.destroy = function() {
	  this.off();
	  this.root();
	};


/***/ },
/* 10 */
/***/ function(module, exports) {

	/* ==========================================================================
	   Events

	   Lightweight mixin to add basic event callback functionality.
	   ========================================================================== */

	'use strict';

	var Events = {

	  on: function( eventName, callback ) {
	    this.events[eventName] = this.events[eventName] || [];
	    this.events[eventName].push( callback );

	    return this;
	  },

	  off: function( eventName ) {
	    if ( this.events[eventName] ) delete this.events[eventName];
	  },

	  trigger: function( eventName ) {
	    this.events[eventName] = this.events[eventName] || [];
	    for ( var i = 0, len = this.events[eventName].length; i < len; i++ ) {
	      this.events[eventName][i].apply( this, arguments );
	    }

	    return this;
	  }

	};

	module.exports = Events;


/***/ },
/* 11 */
/***/ function(module, exports) {

	/* ==========================================================================
	   Atomic Constants

	   ========================================================================== */

	'use strict';

	var TYPES = {
		PAGE: 1,
	  TEMPLATE: 2,
	  ORGANISM: 3,
	  MOLECULE: 4,
	  ATOM: 5
	};

	var PREFIXES = {
		PAGE: 'p-',
	  TEMPLATE: 't-',
	  ORGANISM: 'o-',
	  MOLECULE: 'm-',
	  ATOM: 'a-'
	};

	module.exports = {
	  TYPES : TYPES,
	  PREFIXES : PREFIXES
	}


/***/ }
/******/ ]);